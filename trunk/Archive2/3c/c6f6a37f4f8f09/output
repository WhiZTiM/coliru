main.cpp:202:15: warning: unused parameter 'what' [-Wunused-parameter]
main.cpp:387:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:390:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:394:6: warning: unused parameter 'arg' [-Wunused-parameter]
main.cpp:398:13: warning: unused parameter 'sig' [-Wunused-parameter]
main.cpp:398:13: warning: unused parameter 'si' [-Wunused-parameter]
main.cpp:398:13: warning: unused parameter 'unused' [-Wunused-parameter]
std::thread::hardware_concurrency() = 1
default settings:
    corePoolSize = 1, maximumPoolSize = 1, keepAliveTime = 300000 ms.
new settings:
    corePoolSize = 4, maximumPoolSize = 8, keepAliveTime = 100 ms.
-----------------------------------------------------------------------------------
prestartAllCoreThreads()-->poolSize = 0
prestartAllCoreThreads()-->poolSize = 1
thread no. = 1.  void startRoutine(std::size_t i) {
prestartAllCoreThreads()-->poolSize = 2
thread no. = 2.  void startRoutine(std::size_t i) {
prestartAllCoreThreads()-->poolSize = 3
thread no. = 3.  void startRoutine(std::size_t i) {
thread no. = 4.  void startRoutine(std::size_t i) {
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
void execute(void (*command) (void *), void *arg) {-->} else if (poolSize_ < maximumPoolSize_ && taskQueueSize_/poolSize_ > threshold_) {-->poolSize = 4;taskQueueSize_/poolSize_ = 3
thread no. = 1.  conditionVariable_.wait.woken up
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 2.  conditionVariable_.wait.woken up
thread no. = 2.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 3.  conditionVariable_.wait.woken up
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
void execute(void (*command) (void *), void *arg) {-->} else if (poolSize_ < maximumPoolSize_ && taskQueueSize_/poolSize_ > threshold_) {-->poolSize = 5;taskQueueSize_/poolSize_ = 3
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  void startRoutine(std::size_t i) {
thread no. = 1.  conditionVariable_.wait.woken up
thread no. = 1.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait.woken up
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 3.  if (!timerEnabled) {
thread no. = 1.  if (!timerEnabled) {
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 4.  if (!timerEnabled) {
thread no. = 2.  conditionVariable_.wait.woken up
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 2.  if (!timerEnabled) {
thread no. = 6.  void startRoutine(std::size_t i) {
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 3.  conditionVariable_.wait_for.woken up or timeout
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
conditionVariable_.notify_one();
thread no. = 3.  if (taskQueue_.pop(t)) {
conditionVariable_.notify_one();
thread no. = 3.  if (taskQueue_.pop(t)) {
conditionVariable_.notify_one();
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 3.  if (!timerEnabled) {
thread no. = 5.  conditionVariable_.wait.woken up
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  if (!timerEnabled) {
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 2.  conditionVariable_.wait_for.woken up or timeout
thread no. = 3.  conditionVariable_.wait_for.woken up or timeout
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
conditionVariable_.notify_one();
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 2.  if (!timerEnabled) {
thread no. = 1.  conditionVariable_.wait_for.woken up or timeout
conditionVariable_.notify_one();
thread no. = 1.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
conditionVariable_.notify_one();
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  if (!timerEnabled) {
thread no. = 3.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait.woken up
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  if (taskQueue_.pop(t)) {
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  if (!timerEnabled) {
conditionVariable_.notify_one();
thread no. = 6.  if (!timerEnabled) {
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 1.  conditionVariable_.wait_for.woken up or timeout
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  if (taskQueue_.pop(t)) {
thread no. = 1.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
conditionVariable_.notify_one();
thread no. = 1.  if (!timerEnabled) {
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 3.  conditionVariable_.wait_for.woken up or timeout
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
void execute(void (*command) (void *), void *arg) {-->} else if (poolSize_ < maximumPoolSize_ && taskQueueSize_/poolSize_ > threshold_) {-->poolSize = 6;taskQueueSize_/poolSize_ = 3
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 2.  conditionVariable_.wait_for.woken up or timeout
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 2.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 3.  if (taskQueue_.pop(t)) {
thread no. = 3.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 3.  if (!timerEnabled) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 2.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 1.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  void startRoutine(std::size_t i) {
thread no. = 1.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 2.  if (!timerEnabled) {
conditionVariable_.notify_one();
thread no. = 4.  if (!timerEnabled) {
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
conditionVariable_.notify_one();
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  if (taskQueue_.pop(t)) {
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  if (!timerEnabled) {
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 7.  conditionVariable_.wait.woken up
thread no. = 7.  if (taskQueue_.pop(t)) {
thread no. = 7.  if (taskQueue_.pop(t)) {
thread no. = 7.  if (taskQueue_.pop(t)) {
thread no. = 7.  if (taskQueue_.pop(t)) {
thread no. = 7.  if (taskQueue_.pop(t)) {
thread no. = 7.  if (taskQueue_.pop(t)) {
thread no. = 7.  if (taskQueue_.pop(t)) {
thread no. = 5.  if (taskQueue_.pop(t)) {
thread no. = 2.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 2.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 3.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  if (taskQueue_.pop(t)) {
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 3.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  if (!timerEnabled) {
thread no. = 7.  if (!timerEnabled) {
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 1.  conditionVariable_.wait_for.woken up or timeout
thread no. = 1.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 2.  conditionVariable_.wait_for.woken up or timeout
thread no. = 2.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 2.  terminateTheThread = true;
thread no. = 2.  if (terminateTheThread) {
thread no. = 2.  exit. poolSize = 6
thread no. = 3.  conditionVariable_.wait_for.woken up or timeout
thread no. = 3.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 3.  terminateTheThread = true;
thread no. = 3.  if (terminateTheThread) {
thread no. = 3.  exit. poolSize = 5
thread no. = 1.  conditionVariable_.wait_for.woken up or timeout
thread no. = 1.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 1.  terminateTheThread = true;
thread no. = 1.  if (terminateTheThread) {
thread no. = 1.  exit. poolSize = 4
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
conditionVariable_.notify_one();
thread no. = 5.  conditionVariable_.wait_for.woken up or timeout
thread no. = 5.  if (taskQueue_.pop(t)) {
thread no. = 5.  if (taskQueue_.pop(t)) {
thread no. = 5.  if (taskQueue_.pop(t)) {
thread no. = 5.  if (taskQueue_.pop(t)) {
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  conditionVariable_.wait_for.woken up or timeout
thread no. = 6.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 6.  if (shutdown_) {
thread no. = 6.  exit. poolSize = 3
void execute(void (*command) (void *), void *arg) {-->if (shutdown_) {
void execute(void (*command) (void *), void *arg) {-->if (shutdown_) {
void execute(void (*command) (void *), void *arg) {-->if (shutdown_) {
void execute(void (*command) (void *), void *arg) {-->if (shutdown_) {
thread no. = 5.  conditionVariable_.wait.woken up
thread no. = 5.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 5.  if (shutdown_) {
thread no. = 5.  exit. poolSize = 2
thread no. = 4.  conditionVariable_.wait_for.woken up or timeout
thread no. = 4.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 4.  if (shutdown_) {
thread no. = 4.  exit. poolSize = 1
thread no. = 7.  conditionVariable_.wait_for.woken up or timeout
thread no. = 7.  the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
thread no. = 7.  if (shutdown_) {
thread no. = 7.  exit. poolSize = 0
in awaitTermination.-->if (timeout == 0) {
Clean up.
max threadNo = 7
time = 1.236 s
cnt = 104
CompletedTaskCount = 104
