// BEGIN ========================================== Maxflow [DFS -> O(E * maxflow), BFS -> O(E^2*V), Shotest Path -> O(E*V^2)] ============================================////
//         - MinCostMaxFlow O(V*E*B log V)
#define MF_VERTEX_SIZE 1
#define MF_EDGE_SIZE 1

enum {DFS=0,BFS,SHORTEST};

template<class T, class S>
class FlowNetwork{
public:
  T aug_path_dfs(int cur, int snk, T &lowest){ if(snk == cur) return lowest; T tlowest = lowest;  if(_MFparent[cur] == -1) _MFparent[cur] = -2;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;  lowest = min(tlowest,dir?_MFcapacity[tedge]-_MFflow[tedge]:_MFflow[tedge]); _MFparent[tnext] = cur; if(aug_path_dfs(tnext,snk,lowest)){ _MFflow[tedge] += dir?lowest:-lowest; return lowest;  }}  return 0; }
  T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
  T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
  bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
  void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }

  T getFunction(int src, int snk, int fun, T low = 1000000000){ switch(fun){  case DFS: return aug_path_dfs(src,snk,low);  case BFS: return aug_path_bfs(src,snk,low); case SHORTEST: return aug_path_shortest(src,snk,low); default: return 0;} }

  pair<T,S> minCostMaxFlow(int src, int snk, bool negative=false){ vector<S> dist, pot(MF_VERTEX_SIZE,0); S tmpCost[MF_EDGE_SIZE]; memcpy(tmpCost,_MFcost,sizeof(_MFcost));  vector<int> mapping; FOR(i,0,MF_VERTEX_SIZE) if(_MFadjlist[i].size() > 0) mapping.push_back(i); int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i;  if(negative && !_MFbellmanFord(pot,src,mapping)) return make_pair(-1,-1); FOR(i,0,mapping.size()) ITER(it,_MFadjlist[mapping[i]]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir) continue;  _MFcost[tedge] += pot[i] - pot[hash[tnext]]; }	 T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFdijkstra(dist,src,mapping); if(_MFparent[snk] == -1) break; pot = dist; FOR(i,0,mapping.size()) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir) continue;  _MFcost[tedge] += pot[i] - pot[hash[tnext]]; }	 T tCap = INF; int c = snk; while(c != src){ tCap = min(tCap,_MFpedge[c].second?(_MFcapacity[_MFpedge[c].first]-_MFflow[_MFpedge[c].first]):_MFflow[_MFpedge[c].first]); c = _MFparent[c];} c = snk; while(c != src){ _MFflow[_MFpedge[c].first] += _MFpedge[c].second?tCap:-tCap; c = _MFparent[c]; } ret += tCap; } memcpy(_MFcost,tmpCost,sizeof(_MFcost)); S cost = 0; FOR(i,0,MF_EDGE_SIZE) if(_MFflow[i] > 0) cost += _MFflow[i] * _MFcost[i]; return make_pair(ret,cost); }
  T maxFlow(int src, int snk, int fun){ assert(MF_VERTEX_SIZE!=1 && MF_EDGE_SIZE!=1); T ret = 0; while(true){ memset(_MFparent,-1,sizeof(_MFparent)); T val = getFunction(src,snk,fun); if(val == 0) break; ret+=val;} return ret; }
  S hungarian(int src, int snk){ return src+snk;}

  void initMF(){ assert(MF_EDGE_SIZE!=1 && MF_VERTEX_SIZE!=1); memset(_MFflow,0,sizeof(_MFflow)); memset(_MFcapacity,0,sizeof(_MFcapacity)); FOR(i,0,MF_VERTEX_SIZE) _MFadjlist[i].clear(); _MFedgehash.clear();}
  void reset(){ memset(_MFflow,0,sizeof(_MFflow));}
  void removeMFConnection(int left, int right){ if(_MFedgehash.count(make_pair(left,right)) == 0) return; int e = _MFedgehash[make_pair(left,right)]; _MFflow[e] = 0; _MFcapacity[e] = 0; _MFadjlist[left].erase(make_pair(right,make_pair(e,true))); _MFadjlist[right].erase(make_pair(left,make_pair(e,false)));}
  void addMFConnection(int left, int right, T cap, S cost=0){ int e; if(_MFedgehash.count(make_pair(left,right)) == 0){ e = _MFedgehash[make_pair(left,right)] = _MFedgehash.size()-1; _MFadjlist[left].insert(make_pair(right,make_pair(e,true))); _MFadjlist[right].insert(make_pair(left,make_pair(e,false))); } else e = _MFedgehash[make_pair(left,right)]; _MFflow[e] = 0; _MFcapacity[e] = cap; _MFcost[e]=cost;}

private:
  set<pair<int,pair<int,bool> > > _MFadjlist[MF_VERTEX_SIZE];
  map<pair<int,int>,int> _MFedgehash;
  T _MFflow[MF_EDGE_SIZE], _MFcapacity[MF_EDGE_SIZE];
  S _MFcost[MF_EDGE_SIZE];
  int _MFparent[MF_VERTEX_SIZE], _MFsnkdist[MF_VERTEX_SIZE];
  pair<int,bool> _MFpedge[MF_VERTEX_SIZE];
};
//=================================================================================================================================================================================
