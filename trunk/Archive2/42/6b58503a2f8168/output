main.cpp: In member function 'int B<A>::test(T)':
main.cpp:11:54: error: expected primary-expression before ')' token
         return test(type, std::is_lvalue_reference<T>);
                                                      ^
main.cpp: At global scope:
main.cpp:21:5: error: prototype for 'int B<A>::test(const T&, std::false_type)' does not match any in class 'B<A>'
 int B<A>::test(const T& yolo, std::false_type dummy) {
     ^
main.cpp:16:9: error: candidates are: template<class A> template<class T> int B<A>::test(const T&)
     int test(const T&);
         ^
main.cpp:14:9: error:                 template<class A> template<class T> int B<A>::test(T, std::true_type)
     int test(const T, std::true_type);
         ^
main.cpp:10:9: error:                 template<class A> template<class T> int B<A>::test(T)
     int test(T type) {
         ^
main.cpp: In function 'int main()':
main.cpp:35:32: error: call of overloaded 'test(double)' is ambiguous
         std::cout << b.test(2.0) <<  b.test(1) << std::endl;
                                ^
main.cpp:10:9: note: candidate: int B<A>::test(T) [with T = double; A = int]
     int test(T type) {
         ^
main.cpp:16:9: note: candidate: int B<A>::test(const T&) [with T = double; A = int]
     int test(const T&);
         ^
main.cpp:35:46: error: call of overloaded 'test(int)' is ambiguous
         std::cout << b.test(2.0) <<  b.test(1) << std::endl;
                                              ^
main.cpp:10:9: note: candidate: int B<A>::test(T) [with T = int; A = int]
     int test(T type) {
         ^
main.cpp:16:9: note: candidate: int B<A>::test(const T&) [with T = int; A = int]
     int test(const T&);
         ^
