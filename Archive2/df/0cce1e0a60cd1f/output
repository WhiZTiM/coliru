In file included from /usr/local/include/boost/spirit/home/qi/auxiliary/attr.hpp:18:0,
                 from /usr/local/include/boost/spirit/home/qi/auxiliary.hpp:19,
                 from /usr/local/include/boost/spirit/home/qi.hpp:16,
                 from /usr/local/include/boost/spirit/include/qi.hpp:16,
                 from main.cpp:1:
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp: In instantiation of 'static void boost::spirit::traits::assign_to_attribute_from_value<Attribute, T, Enable>::call(const T_&, Attribute&, mpl_::false_) [with T_ = B; Attribute = int; T = B; Enable = void; mpl_::false_ = mpl_::bool_<false>]':
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:170:17:   required from 'static void boost::spirit::traits::assign_to_attribute_from_value<Attribute, T, Enable>::call(const T&, Attribute&) [with Attribute = int; T = B; Enable = void]'
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:359:63:   required from 'void boost::spirit::traits::detail::assign_to(const T&, Attribute&, mpl_::false_) [with T = B; Attribute = int; mpl_::false_ = mpl_::bool_<false>]'
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:382:26:   required from 'void boost::spirit::traits::assign_to(const T&, Attribute&) [with T = B; Attribute = int]'
/usr/local/include/boost/spirit/home/qi/detail/attributes.hpp:27:30:   required from 'static void boost::spirit::qi::default_transform_attribute<Exposed, Transformed>::post(Exposed&, const Transformed&) [with Exposed = int; Transformed = B]'
/usr/local/include/boost/spirit/home/qi/detail/attributes.hpp:165:75:   required from 'void boost::spirit::traits::post_transform(Exposed&, const Transformed&) [with Exposed = int; Transformed = B]'
/usr/local/include/boost/spirit/home/qi/nonterminal/rule.hpp:308:43:   [ skipping 12 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
/usr/local/include/boost/function/function_template.hpp:728:7:   required from 'boost::function4<R, T1, T2, T3, T4>::function4(Functor, typename boost::enable_if_c<(boost::type_traits::ice_not<(boost::is_integral<Functor>::value)>::value), int>::type) [with Functor = boost::spirit::qi::detail::parser_binder<boost::spirit::qi::expect<boost::fusion::cons<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::reference<const boost::spirit::qi::rule<const char*, A()> >, boost::fusion::cons<boost::spirit::qi::reference<const boost::spirit::qi::rule<const char*, int()> >, boost::fusion::nil_> > >, boost::fusion::cons<boost::spirit::qi::reference<const boost::spirit::qi::rule<const char*, B()> >, boost::fusion::nil_> > >, mpl_::bool_<false> >; R = bool; T0 = const char*&; T1 = const char* const&; T2 = boost::spirit::context<boost::fusion::cons<Synthesized&, boost::fusion::nil_>, boost::fusion::vector0<> >&; T3 = const boost::spirit::unused_type&; typename boost::enable_if_c<(boost::type_traits::ice_not<(boost::is_integral<Functor>::value)>::value), int>::type = int]'
/usr/local/include/boost/function/function_template.hpp:1077:16:   required from 'boost::function<R(T0, T1, T2, T3)>::function(Functor, typename boost::enable_if_c<(boost::type_traits::ice_not<(boost::is_integral<Functor>::value)>::value), int>::type) [with Functor = boost::spirit::qi::detail::parser_binder<boost::spirit::qi::expect<boost::fusion::cons<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::reference<const boost::spirit::qi::rule<const char*, A()> >, boost::fusion::cons<boost::spirit::qi::reference<const boost::spirit::qi::rule<const char*, int()> >, boost::fusion::nil_> > >, boost::fusion::cons<boost::spirit::qi::reference<const boost::spirit::qi::rule<const char*, B()> >, boost::fusion::nil_> > >, mpl_::bool_<false> >; R = bool; T0 = const char*&; T1 = const char* const&; T2 = boost::spirit::context<boost::fusion::cons<Synthesized&, boost::fusion::nil_>, boost::fusion::vector0<> >&; T3 = const boost::spirit::unused_type&; typename boost::enable_if_c<(boost::type_traits::ice_not<(boost::is_integral<Functor>::value)>::value), int>::type = int]'
/usr/local/include/boost/function/function_template.hpp:1132:5:   required from 'typename boost::enable_if_c<(boost::type_traits::ice_not<(boost::is_integral<Functor>::value)>::value), boost::function<R(T0, T1, T2, T3)>&>::type boost::function<R(T0, T1, T2, T3)>::operator=(Functor) [with Functor = boost::spirit::qi::detail::parser_binder<boost::spirit::qi::expect<boost::fusion::cons<boost::spirit::qi::sequence<boost::fusion::cons<boost::spirit::qi::reference<const boost::spirit::qi::rule<const char*, A()> >, boost::fusion::cons<boost::spirit::qi::reference<const boost::spirit::qi::rule<const char*, int()> >, boost::fusion::nil_> > >, boost::fusion::cons<boost::spirit::qi::reference<const boost::spirit::qi::rule<const char*, B()> >, boost::fusion::nil_> > >, mpl_::bool_<false> >; R = bool; T0 = const char*&; T1 = const char* const&; T2 = boost::spirit::context<boost::fusion::cons<Synthesized&, boost::fusion::nil_>, boost::fusion::vector0<> >&; T3 = const boost::spirit::unused_type&; typename boost::enable_if_c<(boost::type_traits::ice_not<(boost::is_integral<Functor>::value)>::value), boost::function<R(T0, T1, T2, T3)>&>::type = boost::function<bool(const char*&, const char* const&, boost::spirit::context<boost::fusion::cons<Synthesized&, boost::fusion::nil_>, boost::fusion::vector0<> >&, const boost::spirit::unused_type&)>&]'
/usr/local/include/boost/spirit/home/qi/nonterminal/rule.hpp:183:19:   required from 'static void boost::spirit::qi::rule<Iterator, T1, T2, T3, T4>::define(boost::spirit::qi::rule<Iterator, T1, T2, T3, T4>&, const Expr&, mpl_::true_) [with Auto = mpl_::bool_<false>; Expr = boost::proto::exprns_::expr<boost::proto::tagns_::tag::greater, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::shift_right, boost::proto::argsns_::list2<boost::spirit::qi::rule<const char*, A()>&, boost::spirit::qi::rule<const char*, int()>&>, 2l>&, boost::spirit::qi::rule<const char*, B()>&>, 2l>; Iterator = const char*; T1 = Synthesized(); T2 = boost::spirit::unused_type; T3 = boost::spirit::unused_type; T4 = boost::spirit::unused_type; mpl_::true_ = mpl_::bool_<true>]'
/usr/local/include/boost/spirit/home/qi/nonterminal/rule.hpp:192:32:   required from 'boost::spirit::qi::rule<Iterator, T1, T2, T3, T4>::rule(const Expr&, const string&) [with Expr = boost::proto::exprns_::expr<boost::proto::tagns_::tag::greater, boost::proto::argsns_::list2<const boost::proto::exprns_::expr<boost::proto::tagns_::tag::shift_right, boost::proto::argsns_::list2<boost::spirit::qi::rule<const char*, A()>&, boost::spirit::qi::rule<const char*, int()>&>, 2l>&, boost::spirit::qi::rule<const char*, B()>&>, 2l>; Iterator = const char*; T1 = Synthesized(); T2 = boost::spirit::unused_type; T3 = boost::spirit::unused_type; T4 = boost::spirit::unused_type; std::__cxx11::string = std::__cxx11::basic_string<char>]'
main.cpp:30:51:   required from here
/usr/local/include/boost/spirit/home/qi/detail/assign_to.hpp:152:18: error: invalid static_cast from type 'const B' to type 'int'
             attr = static_cast<Attribute>(val);
                  ^
