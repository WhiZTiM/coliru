main.cpp:202:45: warning: unused parameter 'what' [-Wunused-parameter]
  virtual void exceptionHandling(const char* what) { 
                                             ^
main.cpp:383:41: warning: unused parameter 'arg' [-Wunused-parameter]
 void read_from_a_file_descriptor (void *arg) {
                                         ^
main.cpp:386:29: warning: unused parameter 'arg' [-Wunused-parameter]
 void throw_std_error (void *arg) {
                             ^
main.cpp:390:24: warning: unused parameter 'arg' [-Wunused-parameter]
 void throw_size (void *arg) {
                        ^
main.cpp:394:32: warning: unused parameter 'sig' [-Wunused-parameter]
 static void signal_handler(int sig, siginfo_t *si, void *unused) {
                                ^
main.cpp:394:48: warning: unused parameter 'si' [-Wunused-parameter]
 static void signal_handler(int sig, siginfo_t *si, void *unused) {
                                                ^
main.cpp:394:58: warning: unused parameter 'unused' [-Wunused-parameter]
 static void signal_handler(int sig, siginfo_t *si, void *unused) {
                                                          ^
std::thread::hardware_concurrency() = 1
default settings:
    corePoolSize = 1, maximumPoolSize = 1, keepAliveTime = 300000 ms.
new settings:
    corePoolSize = 4, maximumPoolSize = 8, keepAliveTime = 100 ms.
-----------------------------------------------------------------------------------
In function prestartAllCoreThreads --> poolSize = 0
In function prestartAllCoreThreads --> poolSize = 1
In function startRoutine --> thread no. = 1 --> start
In function prestartAllCoreThreads --> poolSize = 2
In function startRoutine --> thread no. = 2 --> start
In function prestartAllCoreThreads --> poolSize = 3
In function startRoutine --> thread no. = 3 --> start
In function startRoutine --> thread no. = 4 --> start
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> } else if (poolSize_ < maximumPoolSize_ && taskQueueSize_/poolSize_ > threshold_) { --> poolSize = 4 --> taskQueueSize_/poolSize_ = 3
In function startRoutine --> thread no. = 1 --> conditionVariable_.wait.woken up
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait.woken up
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 3 --> conditionVariable_.wait.woken up
In function startRoutine --> thread no. = 3 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 5 --> start
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> } else if (poolSize_ < maximumPoolSize_ && taskQueueSize_/poolSize_ > threshold_) { --> poolSize = 5 --> taskQueueSize_/poolSize_ = 3
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 3 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 3 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 5 --> conditionVariable_.wait.woken up
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> } else if (poolSize_ < maximumPoolSize_ && taskQueueSize_/poolSize_ > threshold_) { --> poolSize = 6 --> taskQueueSize_/poolSize_ = 3
In function startRoutine --> thread no. = 5 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 5 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> start
In function startRoutine --> thread no. = 1 --> if (!timerEnabled) {
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait.woken up
In function startRoutine --> thread no. = 2 --> if (!timerEnabled) {
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> } else if (poolSize_ < maximumPoolSize_ && taskQueueSize_/poolSize_ > threshold_) { --> poolSize = 7 --> taskQueueSize_/poolSize_ = 3
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 5 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 5 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 5 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 5 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 5 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 5 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 3 --> if (!timerEnabled) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 3 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 3 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 5 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait.woken up
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> if (!timerEnabled) {
In function startRoutine --> thread no. = 7 --> start
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 1 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> if (!timerEnabled) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 1 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 8 --> start
In function startRoutine --> thread no. = 2 --> if (!timerEnabled) {
In function startRoutine --> thread no. = 5 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 1 --> if (!timerEnabled) {
In function startRoutine --> thread no. = 5 --> if (!timerEnabled) {
In function startRoutine --> thread no. = 3 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 3 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 3 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 3 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 3 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 3 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> if (!timerEnabled) {
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 7 --> conditionVariable_.wait.woken up
In function startRoutine --> thread no. = 7 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 3 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 3 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> if (!timerEnabled) {
In function startRoutine --> thread no. = 7 --> if (!timerEnabled) {
In function startRoutine --> thread no. = 3 --> if (!timerEnabled) {
In function startRoutine --> thread no. = 1 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 1 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 1 --> terminateTheThread = true;
In function startRoutine --> thread no. = 1 --> if (terminateTheThread) {
In function startRoutine --> thread no. = 1 --> exit --> poolSize = 7
In function startRoutine --> thread no. = 7 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 5 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 5 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 5 --> terminateTheThread = true;
In function startRoutine --> thread no. = 5 --> if (terminateTheThread) {
In function startRoutine --> thread no. = 5 --> exit --> poolSize = 6
In function startRoutine --> thread no. = 7 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 7 --> terminateTheThread = true;
In function startRoutine --> thread no. = 7 --> if (terminateTheThread) {
In function startRoutine --> thread no. = 7 --> exit --> poolSize = 5
In function startRoutine --> thread no. = 3 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 3 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 3 --> terminateTheThread = true;
In function startRoutine --> thread no. = 3 --> if (terminateTheThread) {
In function startRoutine --> thread no. = 3 --> exit --> poolSize = 4
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function execute --> conditionVariable_.notify_one();
In function startRoutine --> thread no. = 4 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> if (taskQueue_.pop(t)) {
In function startRoutine --> thread no. = 4 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 4 --> if (shutdown_) {
In function startRoutine --> thread no. = 4 --> exit --> poolSize = 3
In function startRoutine --> thread no. = 6 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 6 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 6 --> if (shutdown_) {
In function startRoutine --> thread no. = 6 --> exit --> poolSize = 2
In function execute --> if (shutdown_) {
In function execute --> if (shutdown_) {
In function execute --> if (shutdown_) {
In function execute --> if (shutdown_) {
In function startRoutine --> thread no. = 2 --> conditionVariable_.wait_for.woken up or timeout
In function startRoutine --> thread no. = 2 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 2 --> if (shutdown_) {
In function startRoutine --> thread no. = 2 --> exit --> poolSize = 1
In function startRoutine --> thread no. = 8 --> conditionVariable_.wait.woken up
In function startRoutine --> thread no. = 8 --> the queue is empty. std::lock_guard<std::mutex> lock(terminateTheThreadMutex_);
In function startRoutine --> thread no. = 8 --> if (shutdown_) {
In function startRoutine --> thread no. = 8 --> exit --> poolSize = 0
In function awaitTermination --> if (timeout == 0) {
In function main --> Clean up.
In function main --> max threadNo = 8
In function main --> time = 1.23597 s
In function main --> cnt = 104
In function main --> CompletedTaskCount = 104
