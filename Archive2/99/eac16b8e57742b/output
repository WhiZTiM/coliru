main.cpp:14:23: error: 'vector' has not been declared
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                       ^
main.cpp:14:29: error: expected ',' or '...' before '<' token
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                             ^
main.cpp:15:20: error: 'vector' has not been declared
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                    ^
main.cpp:15:26: error: expected ',' or '...' before '<' token
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                          ^
main.cpp:19:3: error: 'pair' does not name a type
   pair<T,S> minCostMaxFlow(int src, int snk, bool negative=false){ vector<S> dist, pot(MF_VERTEX_SIZE,0); S tmpCost[MF_EDGE_SIZE]; memcpy(tmpCost,_MFcost,sizeof(_MFcost));  vector<int> mapping; FOR(i,0,MF_VERTEX_SIZE) if(_MFadjlist[i].size() > 0) mapping.push_back(i); int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i;  if(negative && !_MFbellmanFord(pot,src,mapping)) return make_pair(-1,-1); FOR(i,0,mapping.size()) ITER(it,_MFadjlist[mapping[i]]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir) continue;  _MFcost[tedge] += pot[i] - pot[hash[tnext]]; }  T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFdijkstra(dist,src,mapping); if(_MFparent[snk] == -1) break; pot = dist; FOR(i,0,mapping.size()) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir) continue;  _MFcost[tedge] += pot[i] - pot[hash[tnext]]; }  T tCap = INF; int c = snk; while(c != src){ tCap = min(tCap,_MFpedge[c].second?(_MFcapacity[_MFpedge[c].first]-_MFflow[_MFpedge[c].first]):_MFflow[_MFpedge[c].first]); c = _MFparent[c];} c = snk; while(c != src){ _MFflow[_MFpedge[c].first] += _MFpedge[c].second?tCap:-tCap; c = _MFparent[c]; } ret += tCap; } memcpy(_MFcost,tmpCost,sizeof(_MFcost)); S cost = 0; FOR(i,0,MF_EDGE_SIZE) if(_MFflow[i] > 0) cost += _MFflow[i] * _MFcost[i]; return make_pair(ret,cost); }
   ^
main.cpp:29:3: error: 'set' does not name a type
   set<pair<int,pair<int,bool> > > _MFadjlist[MF_VERTEX_SIZE];
   ^
main.cpp:30:3: error: 'map' does not name a type
   map<pair<int,int>,int> _MFedgehash;
   ^
main.cpp:34:3: error: 'pair' does not name a type
   pair<int,bool> _MFpedge[MF_VERTEX_SIZE];
   ^
main.cpp: In member function 'T FlowNetwork<T, S>::aug_path_dfs(int, int, T&)':
main.cpp:11:151: error: 'it' was not declared in this scope
   T aug_path_dfs(int cur, int snk, T &lowest){ if(snk == cur) return lowest; T tlowest = lowest;  if(_MFparent[cur] == -1) _MFparent[cur] = -2;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;  lowest = min(tlowest,dir?_MFcapacity[tedge]-_MFflow[tedge]:_MFflow[tedge]); _MFparent[tnext] = cur; if(aug_path_dfs(tnext,snk,lowest)){ _MFflow[tedge] += dir?lowest:-lowest; return lowest;  }}  return 0; }
                                                                                                                                                       ^
main.cpp:11:154: error: '_MFadjlist' was not declared in this scope
   T aug_path_dfs(int cur, int snk, T &lowest){ if(snk == cur) return lowest; T tlowest = lowest;  if(_MFparent[cur] == -1) _MFparent[cur] = -2;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;  lowest = min(tlowest,dir?_MFcapacity[tedge]-_MFflow[tedge]:_MFflow[tedge]); _MFparent[tnext] = cur; if(aug_path_dfs(tnext,snk,lowest)){ _MFflow[tedge] += dir?lowest:-lowest; return lowest;  }}  return 0; }
                                                                                                                                                          ^
main.cpp:11:169: error: there are no arguments to 'ITER' that depend on a template parameter, so a declaration of 'ITER' must be available [-fpermissive]
   T aug_path_dfs(int cur, int snk, T &lowest){ if(snk == cur) return lowest; T tlowest = lowest;  if(_MFparent[cur] == -1) _MFparent[cur] = -2;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;  lowest = min(tlowest,dir?_MFcapacity[tedge]-_MFflow[tedge]:_MFflow[tedge]); _MFparent[tnext] = cur; if(aug_path_dfs(tnext,snk,lowest)){ _MFflow[tedge] += dir?lowest:-lowest; return lowest;  }}  return 0; }
                                                                                                                                                                         ^
main.cpp:11:169: note: (if you use '-fpermissive', G++ will accept your code, but allowing the use of an undeclared name is deprecated)
main.cpp:11:170: error: expected ';' before '{' token
   T aug_path_dfs(int cur, int snk, T &lowest){ if(snk == cur) return lowest; T tlowest = lowest;  if(_MFparent[cur] == -1) _MFparent[cur] = -2;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;  lowest = min(tlowest,dir?_MFcapacity[tedge]-_MFflow[tedge]:_MFflow[tedge]); _MFparent[tnext] = cur; if(aug_path_dfs(tnext,snk,lowest)){ _MFflow[tedge] += dir?lowest:-lowest; return lowest;  }}  return 0; }
                                                                                                                                                                          ^
main.cpp:11:567: error: expected '}' at end of input
   T aug_path_dfs(int cur, int snk, T &lowest){ if(snk == cur) return lowest; T tlowest = lowest;  if(_MFparent[cur] == -1) _MFparent[cur] = -2;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;  lowest = min(tlowest,dir?_MFcapacity[tedge]-_MFflow[tedge]:_MFflow[tedge]); _MFparent[tnext] = cur; if(aug_path_dfs(tnext,snk,lowest)){ _MFflow[tedge] += dir?lowest:-lowest; return lowest;  }}  return 0; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
main.cpp: In member function 'T FlowNetwork<T, S>::aug_path_bfs(int, int, T&)':
main.cpp:12:110: error: there are no arguments to 'memset' that depend on a template parameter, so a declaration of 'memset' must be available [-fpermissive]
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                              ^
main.cpp:12:142: error: '_MFpedge' was not declared in this scope
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                              ^
main.cpp:12:170: error: there are no arguments to 'memset' that depend on a template parameter, so a declaration of 'memset' must be available [-fpermissive]
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                          ^
main.cpp:12:206: error: there are no arguments to 'make_pair' that depend on a template parameter, so a declaration of 'make_pair' must be available [-fpermissive]
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                              ^
main.cpp:12:210: error: 'queue' was not declared in this scope
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                                  ^
main.cpp:12:216: error: expected primary-expression before 'int'
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                                        ^
main.cpp:12:224: error: 'q' was not declared in this scope
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                                                ^
main.cpp:12:244: error: expected primary-expression before '>' token
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                                                                    ^
main.cpp:12:246: error: 'p' was not declared in this scope
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                                                                      ^
main.cpp:12:397: error: 'it' was not declared in this scope
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                                                                                                                                                                                                                             ^
main.cpp:12:400: error: '_MFadjlist' was not declared in this scope
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                                                                                                                                                                                                                                ^
main.cpp:12:413: error: there are no arguments to 'ITER' that depend on a template parameter, so a declaration of 'ITER' must be available [-fpermissive]
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                                                                                                                                                                                                                                             ^
main.cpp:12:414: error: expected ';' before '{' token
   T aug_path_bfs(int src, int snk, T &lowest){ T ret = 0; while(true){  memset(_MFparent,-1,sizeof(_MFparent)); _MFparent[src] = -2;  memset(_MFpedge,-1,sizeof(_MFpedge)); _MFpedge[src] = make_pair(-2,true);  queue<int> q; q.push(src); queue<T> p; p.push(lowest); T tmp = 0; while(!q.empty()){  int c = q.front(); q.pop();  T clow = p.front(); p.pop();  if(c == snk) { tmp = clow; break;}   ITER(it,_MFadjlist[c]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFparent[tnext]!=-1) continue;   _MFparent[tnext] = c; _MFpedge[tnext] = make_pair(tedge,dir);  p.push(min(clow,dir?_MFcapacity[tedge] - _MFflow[tedge]:_MFflow[tedge]));  q.push(tnext); }  }  if(tmp==0) break;  ret += tmp;   int c = snk;  while(c != src){ _MFflow[_MFpedge[c].first] += (_MFpedge[c].second)?tmp:-tmp; c = _MFparent[c]; }  } return ret;  }
                                                                                                                                                                                                                                                                                                                                                                                                                              ^
main.cpp: In member function 'T FlowNetwork<T, S>::aug_path_shortest(int, int, T&)':
main.cpp:13:92: error: there are no arguments to 'memset' that depend on a template parameter, so a declaration of 'memset' must be available [-fpermissive]
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                            ^
main.cpp:13:116: error: 'queue' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                    ^
main.cpp:13:122: error: expected primary-expression before 'int'
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                          ^
main.cpp:13:130: error: 'q' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                  ^
main.cpp:13:144: error: 'set' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                ^
main.cpp:13:148: error: 'pair' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                    ^
main.cpp:13:153: error: expected primary-expression before 'int'
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                         ^
main.cpp:13:271: error: 'itarray' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                               ^
main.cpp:13:284: error: '_MFadjlist' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                            ^
main.cpp:13:318: error: 'it' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                              ^
main.cpp:13:334: error: there are no arguments to 'ITER' that depend on a template parameter, so a declaration of 'ITER' must be available [-fpermissive]
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                              ^
main.cpp:13:335: error: expected ';' before '{' token
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                               ^
main.cpp:13:663: error: there are no arguments to 'memset' that depend on a template parameter, so a declaration of 'memset' must be available [-fpermissive]
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
main.cpp:13:674: error: '_MFpedge' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
main.cpp:13:702: error: there are no arguments to 'memset' that depend on a template parameter, so a declaration of 'memset' must be available [-fpermissive]
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
main.cpp:13:760: error: there are no arguments to 'make_pair' that depend on a template parameter, so a declaration of 'make_pair' must be available [-fpermissive]
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
main.cpp:13:850: error: expected primary-expression before 'int'
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
main.cpp:13:899: error: 'it' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
main.cpp:13:903: error: '_MFadjlist' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
main.cpp:13:933: error: 'itarray' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
main.cpp:13:1032: error: 'dir' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
main.cpp:13:1138: error: 'tnext' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
main.cpp:13:1207: error: 'tnext' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
main.cpp:13:1255: error: 'dir' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
main.cpp:13:1258: error: there are no arguments to 'make_pair' that depend on a template parameter, so a declaration of 'make_pair' must be available [-fpermissive]
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
main.cpp:13:1472: error: there are no arguments to 'min' that depend on a template parameter, so a declaration of 'min' must be available [-fpermissive]
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
main.cpp:13:1664: error: 'it' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
main.cpp:13:1667: error: '_MFadjlist' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
main.cpp:13:1682: error: there are no arguments to 'ITER' that depend on a template parameter, so a declaration of 'ITER' must be available [-fpermissive]
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
main.cpp:13:1683: error: expected ';' before '{' token
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
main.cpp:13:1941: error: 'itarray' was not declared in this scope
   T aug_path_shortest(int src, int snk, T &lowest){ memset(_MFsnkdist,-1,sizeof(_MFsnkdist)); _MFsnkdist[snk] = 0; queue<int> q; q.push(snk);  set<pair<int,pair<int,bool> > >::iterator itarray[MF_VERTEX_SIZE]; int N = 0;  while(!q.empty()){ int c = q.front(); q.pop();  itarray[c] = _MFadjlist[c].begin(); N++;  ITER(it,_MFadjlist[c]){   int tedge = (it->second).first, dir = (it->second).second , tnext = it->first;  if(_MFsnkdist[tnext]!=-1 || !dir &&  _MFflow[tedge] >= _MFcapacity[tedge] || dir && _MFflow[tedge]==0) continue;  _MFsnkdist[tnext] = _MFsnkdist[c]+1; q.push(tnext);  }  }  if(_MFsnkdist[src]==-1) return 0; memset(_MFparent,-1,sizeof(_MFparent));  memset(_MFpedge,-1,sizeof(_MFpedge));  _MFparent[src] = -2; _MFpedge[src] = make_pair(-2,true); int cur = src, ret = 0;  while(_MFsnkdist[src] < N){  bool any = false;   for(set<pair<int,pair<int,bool> > >::iterator it=itarray[cur];it!=_MFadjlist[cur].end();it++){  itarray[cur]++;  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[cur] != _MFsnkdist[tnext]+1 || _MFsnkdist[tnext]==-1) continue;   any = true; _MFparent[tnext] = cur; _MFpedge[tnext] = make_pair(tedge,dir); cur = tnext;  if(cur == snk){ int tc = cur, low = lowest;  while(tc!=src){  low = min(low,_MFpedge[tnext].second?_MFcapacity[_MFpedge[tnext].first] - _MFflow[_MFpedge[tnext].first]:_MFflow[_MFpedge[tnext].first]);  tc = _MFparent[tc]; }  while(cur != src){  _MFflow[_MFpedge[cur].first] += _MFpedge[cur].second?low:-low;  cur = _MFparent[cur]; }  ret += low;  }  break; }  if(!any){  int low = N;  ITER(it,_MFadjlist[cur]){  int tedge = (it->second).first, dir = (it->second).second, tnext = it->first;  if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0 || _MFsnkdist[tnext]==-1) continue;  low = min(low,_MFsnkdist[tnext]+1);  }  _MFsnkdist[cur] = low; itarray[cur] = _MFadjlist[cur].begin(); if(cur != src) cur = _MFparent[cur]; } } return ret; }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
main.cpp: In member function 'bool FlowNetwork<T, S>::_MFbellmanFord(int)':
main.cpp:14:87: error: 'mapping' was not declared in this scope
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                       ^
main.cpp:14:103: error: 'dist' was not declared in this scope
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                       ^
main.cpp:14:110: error: 'vector' was not declared in this scope
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                              ^
main.cpp:14:118: error: expected primary-expression before '>' token
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                      ^
main.cpp:14:122: error: 'INF' was not declared in this scope
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                          ^
main.cpp:14:147: error: there are no arguments to 'MEMSET' that depend on a template parameter, so a declaration of 'MEMSET' must be available [-fpermissive]
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                   ^
main.cpp:14:163: error: 'start' was not declared in this scope
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                   ^
main.cpp:14:206: error: 'i' was not declared in this scope
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                                                              ^
main.cpp:14:224: error: there are no arguments to 'FOR' that depend on a template parameter, so a declaration of 'FOR' must be available [-fpermissive]
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                                                                                ^
main.cpp:14:226: error: expected ';' before 'hash'
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                                                                                  ^
main.cpp:14:274: error: there are no arguments to 'FOR' that depend on a template parameter, so a declaration of 'FOR' must be available [-fpermissive]
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                                                                                                                                  ^
main.cpp:14:276: error: expected ';' before 'c'
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                                                                                                                                    ^
main.cpp:14:316: error: 'k' was not declared in this scope
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                                                                                                                                                                            ^
main.cpp:14:323: error: there are no arguments to 'FOR' that depend on a template parameter, so a declaration of 'FOR' must be available [-fpermissive]
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                                                                                                                                                                                   ^
main.cpp:14:324: error: expected ';' before '{' token
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                                                                                                                                                                                    ^
main.cpp:14:1109: error: expected '}' at end of input
   bool _MFbellmanFord(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); MEMSET(_MFparent,-1); dist[mapping[start]] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; long long c = 0; FOR(i,0,N) c += _MFadjlist[mapping[i]].size(); FOR(k,0,N-1){  bool any = false; FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]) < dist[hash[tnext]]){ dist[hash[tnext]] = dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge]);  _MFparent[tnext] = mapping[i]; _MFpedge[tnext] = make_pair(tedge,dir); any = true; } } if(!any) break; } FOR(i,0,N) ITER(it,_MFadjlist[mapping[i]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[hash[tnext]] > dist[i] + (dir?_MFcost[tedge]:-_MFcost[tedge])) return false;  } return true;}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
main.cpp:14:1109: warning: no return statement in function returning non-void [-Wreturn-type]
main.cpp: In member function 'void FlowNetwork<T, S>::_MFdijkstra(int)':
main.cpp:15:84: error: 'mapping' was not declared in this scope
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                    ^
main.cpp:15:100: error: 'dist' was not declared in this scope
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                    ^
main.cpp:15:107: error: 'vector' was not declared in this scope
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                           ^
main.cpp:15:115: error: expected primary-expression before '>' token
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                   ^
main.cpp:15:119: error: 'INF' was not declared in this scope
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                       ^
main.cpp:15:130: error: 'start' was not declared in this scope
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                  ^
main.cpp:15:172: error: 'i' was not declared in this scope
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                            ^
main.cpp:15:190: error: there are no arguments to 'FOR' that depend on a template parameter, so a declaration of 'FOR' must be available [-fpermissive]
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                                              ^
main.cpp:15:192: error: expected ';' before 'hash'
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                                                ^
main.cpp:15:221: error: expected primary-expression before 'int'
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                                                                             ^
main.cpp:15:242: error: 'pair' was not declared in this scope
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                                                                                                  ^
main.cpp:15:248: error: expected primary-expression before ',' token
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                                                                                                        ^
main.cpp:15:249: error: expected primary-expression before 'int'
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                                                                                                         ^
main.cpp:15:271: error: there are no arguments to 'FOR' that depend on a template parameter, so a declaration of 'FOR' must be available [-fpermissive]
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                                                                                                                               ^
main.cpp:15:273: error: expected ';' before 'heap'
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                                                                                                                                 ^
main.cpp:15:328: error: 'heap' was not declared in this scope
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist[i],i)); make_heap(BEGEND(heap),greater<pair<int,S> >());  FOR(i,0,N) hPos[heap[i].second] = i;  while(heap.size() > 0){  pair<S,int> lowest = heap[0]; swap(heap[0],heap[heap.size()-1]); swap(hPos[heap[0].second], hPos[heap[heap.size()-1].second]); heap.pop_back(); if(lowest.first == INF) break; int pos = 1;  while(pos*2 <= heap.size() && (heap[pos-1] > heap[pos*2-1] || pos*2<heap.size() && heap[pos-1] > heap[pos*2])){   if(pos*2 == heap.size() || heap[pos*2] >= heap[pos*2-1]){  swap(heap[pos-1],heap[pos*2-1]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2-1].second]);  pos = pos*2; } else { swap(heap[pos-1],heap[pos*2]); swap(hPos[heap[pos-1].second],hPos[heap[pos*2].second]); pos = pos*2+1;}  }  ITER(it,_MFadjlist[mapping[lowest.second]]){ int tedge = (it->second).first, dir = (it->second).second, tnext = it->first; if(dir && _MFflow[tedge] >= _MFcapacity[tedge] || !dir && _MFflow[tedge]==0) continue; if(dist[lowest.second] + (dir?_MFcost[tedge]:0) < dist[hash[tnext]]){  dist[hash[tnext]] = dist[lowest.second] + (dir?_MFcost[tedge]:0);  _MFparent[tnext] = mapping[lowest.second]; _MFpedge[tnext] = make_pair(tedge,dir); int p = hPos[hash[tnext]];  heap[p].first = dist[hash[tnext]]; while(p > 0 && heap[p] < heap[((p+1)>>1)-1]){ swap(heap[p],heap[((p+1)>>1)-1]); swap(hPos[heap[p].second],hPos[heap[((p+1)>>1)-1].second]);  p = (((p+1)>>1)-1); } } } } }
                                                                                                                                                                                                                                                                                                                                        ^
main.cpp:15:332: error: there are no arguments to 'BEGEND' that depend on a template parameter, so a declaration of 'BEGEND' must be available [-fpermissive]
   void _MFdijkstra(vector<S> &dist, int start, const vector<int> mapping){ int N = mapping.size(); dist = vector<S>(N,INF); dist[start] = 0; int hash[MF_VERTEX_SIZE]; FOR(i,0,mapping.size()) hash[mapping[i]] = i; vector<int> hPos(N); vector<pair<S,int> > heap; FOR(i,0,N) heap.push_back(make_pair(dist